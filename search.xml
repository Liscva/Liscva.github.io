<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>List转Map之Collectors.toMap</title>
      <link href="2020/10/10/java/%E5%B0%8F%E6%8A%80%E5%B7%A7/List%E5%BF%AB%E9%80%9F%E8%BD%ACMap/"/>
      <url>2020/10/10/java/%E5%B0%8F%E6%8A%80%E5%B7%A7/List%E5%BF%AB%E9%80%9F%E8%BD%ACMap/</url>
      
        <content type="html"><![CDATA[<pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> jdk8<span class="token punctuation">.</span>stream<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>List<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Map<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>stream<span class="token punctuation">.</span>Collectors<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * User: 李诗诚 * Date: 2020/10/10 * Time: 17:09 * Description: */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ListToMap</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>User<span class="token operator">></span> users <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>                <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token number">101</span><span class="token punctuation">,</span> <span class="token string">"Jack"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token number">102</span><span class="token punctuation">,</span> <span class="token string">"Kreas"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token number">103</span><span class="token punctuation">,</span> <span class="token string">"Marry"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token number">103</span><span class="token punctuation">,</span> <span class="token string">"Timi"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token number">105</span><span class="token punctuation">,</span> <span class="token string">"Alice"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//List 转 Map，值为对象：</span>        <span class="token comment" spellcheck="true">// Map&lt;Long,User> map = users.stream().collect(Collectors.toMap(User::getId,o->o));</span>        <span class="token comment" spellcheck="true">//List 转 Map，值为属性：</span>        <span class="token comment" spellcheck="true">// Map&lt;Long, String> map = users.stream().collect(Collectors.toMap(User::getId, User::getName));</span>        <span class="token comment" spellcheck="true">//List 转 Map，值为属性,且二次加工：</span>        <span class="token comment" spellcheck="true">//Map&lt;Long, String> map = users.stream().collect(Collectors.toMap(User::getId, o -> o.getName() + "_OK"));</span>        <span class="token comment" spellcheck="true">//Map KEY不能重复,(o1,o2)->o1,取排在前面的</span>        Map<span class="token operator">&lt;</span>Long<span class="token punctuation">,</span>User<span class="token operator">></span> map <span class="token operator">=</span> users<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toMap</span><span class="token punctuation">(</span>User<span class="token operator">:</span><span class="token operator">:</span>getId<span class="token punctuation">,</span>o<span class="token operator">-</span><span class="token operator">></span>o<span class="token punctuation">,</span><span class="token punctuation">(</span>o1<span class="token punctuation">,</span>o2<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span>o1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>key <span class="token operator">-</span><span class="token operator">></span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"map.get("</span> <span class="token operator">+</span> key <span class="token operator">+</span> <span class="token string">") = "</span> <span class="token operator">+</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 用户ID</span>        <span class="token keyword">private</span> <span class="token keyword">long</span> id<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 用户名称</span>        <span class="token keyword">private</span> String name<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token function">User</span><span class="token punctuation">(</span><span class="token keyword">long</span> id<span class="token punctuation">,</span> String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> id<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setId</span><span class="token punctuation">(</span><span class="token keyword">long</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> name<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token string">"User{"</span> <span class="token operator">+</span>                    <span class="token string">"id="</span> <span class="token operator">+</span> id <span class="token operator">+</span>                    <span class="token string">", name='"</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">'\''</span> <span class="token operator">+</span>                    <span class="token string">'}'</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 小技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一.elasticsearch入门安装使用</title>
      <link href="2020/10/10/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/elasticsearch/%E4%B8%80.elasticsearch%E5%85%A5%E9%97%A8%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/"/>
      <url>2020/10/10/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/elasticsearch/%E4%B8%80.elasticsearch%E5%85%A5%E9%97%A8%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>安装环境是centos7,由于kafka很多核心基于zookeeper特性实现,而zookeeper是java编写运行在JVM上,所以需要保证有java8以上的JDK环境</p><h2 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h2><p><a href="https://www.elastic.co/cn/downloads/elasticsearch">https://www.elastic.co/cn/downloads/elasticsearch</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> elasticsearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 搜索引擎 </tag>
            
            <tag> elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一.ConditionalOnProperty</title>
      <link href="2020/10/10/%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E8%AF%B4%E6%98%8E/%E4%B8%80.ConditionalOnProperty/"/>
      <url>2020/10/10/%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E8%AF%B4%E6%98%8E/%E4%B8%80.ConditionalOnProperty/</url>
      
        <content type="html"><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><blockquote><p><strong>Spring Boot</strong>通过**@ConditionalOnProperty<strong>来控制</strong>Configuration**是否生效</p></blockquote><h2 id="2-说明"><a href="#2-说明" class="headerlink" title="2. 说明"></a>2. 说明</h2><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span> ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">,</span> ElementType<span class="token punctuation">.</span>METHOD <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Conditional</span><span class="token punctuation">(</span>OnPropertyCondition<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">ConditionalOnProperty</span> <span class="token punctuation">{</span>    String<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//数组，获取对应property名称的值，与name不可同时使用  </span>    String <span class="token function">prefix</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//property名称的前缀，可有可无  </span>    String<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//数组，property完整名称或部分名称（可与prefix组合使用，组成完整的property名称），与value不可同时使用  </span>    String <span class="token function">havingValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//可与name组合使用，比较获取到的属性值与havingValue给定的值是否相同，相同才加载配置  </span>    <span class="token keyword">boolean</span> <span class="token function">matchIfMissing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//缺少该property时是否可以加载。如果为true，没有该property也会正常加载；反之报错  </span>    <span class="token keyword">boolean</span> <span class="token function">relaxedNames</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//是否可以松散匹配，至今不知道怎么使用的  </span><span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><h2 id="3-使用方法"><a href="#3-使用方法" class="headerlink" title="3. 使用方法"></a>3. 使用方法</h2><blockquote><p>通过其两个属性<strong>name</strong>以及<strong>havingValue</strong>来实现的，其中<strong>name</strong>用来从<strong>application.properties</strong>中读取某个属性值。<br> <strong>如果该值为空，则返回false</strong>;<br> <strong>如果值不为空，则将该值与havingValue指定的值进行比较，如果一样则返回true;否则返回false。</strong><br> <strong>如果返回值为false，则该configuration不生效；为true则生效。</strong></p></blockquote><h2 id="4-code"><a href="#4-code" class="headerlink" title="4. code"></a>4. code</h2><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token comment" spellcheck="true">//在application.properties配置"mf.assert"，对应的值为true</span><span class="token annotation punctuation">@ConditionalOnProperty</span><span class="token punctuation">(</span>prefix<span class="token operator">=</span><span class="token string">"mf"</span><span class="token punctuation">,</span>name <span class="token operator">=</span> <span class="token string">"assert"</span><span class="token punctuation">,</span> havingValue <span class="token operator">=</span> <span class="token string">"true"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AssertConfig</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> HelloServiceProperties helloServiceProperties<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> HelloService <span class="token function">helloService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        HelloService helloService <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HelloService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        helloService<span class="token punctuation">.</span><span class="token function">setMsg</span><span class="token punctuation">(</span>helloServiceProperties<span class="token punctuation">.</span><span class="token function">getMsg</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> helloService<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 注解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
            <tag> 注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二.kafka入门理解</title>
      <link href="2020/10/10/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/%E4%BA%8C.kafka%E5%85%A5%E9%97%A8%E7%90%86%E8%A7%A3/"/>
      <url>2020/10/10/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/%E4%BA%8C.kafka%E5%85%A5%E9%97%A8%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="Kafka的基本介绍"><a href="#Kafka的基本介绍" class="headerlink" title="Kafka的基本介绍"></a>Kafka的基本介绍</h3><p>Kafka是最初由Linkedin公司开发，是一个分布式、分区的、多副本的、多订阅者，基于zookeeper协调的分布式日志系统（也可以当做MQ系统），常见可以用于web/nginx日志、访问日志，消息服务等等，Linkedin于2010年贡献给了Apache基金会并成为顶级开源项目。</p><p>主要应用场景是：日志收集系统和消息系统。</p><h3 id="Kafka专用术语："><a href="#Kafka专用术语：" class="headerlink" title="Kafka专用术语："></a>Kafka专用术语：</h3><ul><li>Broker：消息中间件处理结点，一个Kafka节点就是一个broker，多个broker可以组成一个Kafka集群。</li><li>Topic：一类消息或者叫主题，Kafka集群能够同时负责多个topic的分发。</li><li>Partition：topic物理上的分组，一个topic可以分为多个partition，每个partition是一个有序的队列。</li><li>Segment：partition物理上由多个segment组成。</li><li>offset：每个partition都由一系列有序的、不可变的消息组成，这些消息被连续的追加到partition中。partition中的每个消息都有一个连续的序列号叫做offset，用于partition唯一标识一条消息。</li><li>Producer：负责发布消息到Kafka broker。</li><li>Consumer：消息消费者，向Kafka broker读取消息的客户端。</li><li>Consumer Group：每个Consumer属于一个特定的Consumer Group。</li></ul><h3 id="Kafka的设计原理分析"><a href="#Kafka的设计原理分析" class="headerlink" title="Kafka的设计原理分析"></a>Kafka的设计原理分析</h3><p><img src="/2020/10/10/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/%E4%BA%8C.kafka%E5%85%A5%E9%97%A8%E7%90%86%E8%A7%A3/image-20201010145717763.png" alt="image-20201010145717763"></p><p>一个典型的kafka集群中包含若干producer，若干broker，若干consumer，以及一个Zookeeper集群。</p><p>Kafka通过Zookeeper管理集群配置，选举leader，以及在consumer group发生变化时进行rebalance。producer使用push模式将消息发布到broker，consumer使用pull模式从broker订阅并消费消息。</p><h3 id="Kafka数据传输的事务特点"><a href="#Kafka数据传输的事务特点" class="headerlink" title="Kafka数据传输的事务特点"></a>Kafka数据传输的事务特点</h3><p>at most once：最多一次，这个和JMS中”非持久化”消息类似，发送一次，无论成败，将不会重发。消费者fetch消息，然后保存offset，然后处理消息；当client保存offset之后，但是在消息处理过程中出现了异常，导致部分消息未能继续处理。那么此后”未处理”的消息将不能被fetch到，这就是”at most once”。</p><p>at least once：消息至少发送一次，如果消息未能接受成功，可能会重发，直到接收成功。消费者fetch消息，然后处理消息，然后保存offset。如果消息处理成功之后，但是在保存offset阶段zookeeper异常导致保存操作未能执行成功，这就导致接下来再次fetch时可能获得上次已经处理过的消息，这就是”at least once”，原因offset没有及时的提交给zookeeper，zookeeper恢复正常还是之前offset状态。</p><p>exactly once：消息只会发送一次。kafka中并没有严格的去实现（基于2阶段提交），我们认为这种策略在kafka中是没有必要的。</p><p>通常情况下”at-least-once”是我们首选。</p><h3 id="Kafka消息存储格式"><a href="#Kafka消息存储格式" class="headerlink" title="Kafka消息存储格式"></a>Kafka消息存储格式</h3><p><strong>Topic &amp; Partition</strong></p><p>一个topic可以认为一个一类消息，每个topic将被分成多个partition，每个partition在存储层面是append log文件。</p><p><img src="/2020/10/10/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/%E4%BA%8C.kafka%E5%85%A5%E9%97%A8%E7%90%86%E8%A7%A3/20170803142135185" alt="图片描述"></p><p>在Kafka文件存储中，同一个topic下有多个不同partition，每个partition为一个目录，partiton命名规则为topic名称+有序序号，第一个partiton序号从0开始，序号最大值为partitions数量减1。</p><p><img src="/2020/10/10/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/%E4%BA%8C.kafka%E5%85%A5%E9%97%A8%E7%90%86%E8%A7%A3/20170803142219160" alt="图片描述"></p><ul><li>每个partion（目录）相当于一个巨型文件被平均分配到多个大小相等segment（段）数据文件中。但每个段segment file消息数量不一定相等，这种特性方便old segment file快速被删除。</li><li>每个partiton只需要支持顺序读写就行了，segment文件生命周期由服务端配置参数决定。</li></ul><p>这样做的好处就是能快速删除无用文件，有效提高磁盘利用率。</p><ul><li>segment file组成：由2大部分组成，分别为index file和data file，此2个文件一一对应，成对出现，后缀”.index”和“.log”分别表示为segment索引文件、数据文件。</li><li>segment文件命名规则：partion全局的第一个segment从0开始，后续每个segment文件名为上一个segment文件最后一条消息的offset值。数值最大为64位long大小，19位数字字符长度，没有数字用0填充。</li></ul><p><img src="/2020/10/10/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/%E4%BA%8C.kafka%E5%85%A5%E9%97%A8%E7%90%86%E8%A7%A3/20170803142330885" alt="图片描述"></p><p>segment中index与data file对应关系物理结构如下：</p><p><img src="/2020/10/10/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/%E4%BA%8C.kafka%E5%85%A5%E9%97%A8%E7%90%86%E8%A7%A3/20170803142353099" alt="图片描述"></p><p>上图中索引文件存储大量元数据，数据文件存储大量消息，索引文件中元数据指向对应数据文件中message的物理偏移地址。</p><p>其中以索引文件中元数据3,497为例，依次在数据文件中表示第3个message（在全局partiton表示第368772个message），以及该消息的物理偏移地址为497。</p><p>了解到segment data file由许多message组成，下面详细说明message物理结构如下：</p><p><img src="/2020/10/10/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/%E4%BA%8C.kafka%E5%85%A5%E9%97%A8%E7%90%86%E8%A7%A3/20170803142529576" alt="图片描述"></p><p>参数说明：</p><p><img src="/2020/10/10/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/%E4%BA%8C.kafka%E5%85%A5%E9%97%A8%E7%90%86%E8%A7%A3/20170803142601663" alt="图片描述"></p><p><strong>副本（replication）策略</strong></p><p>Kafka的高可靠性的保障来源于其健壮的副本（replication）策略。</p><p><strong>1) 数据同步</strong></p><p>kafka在0.8版本前没有提供Partition的Replication机制，一旦Broker宕机，其上的所有Partition就都无法提供服务，而Partition又没有备份数据，数据的可用性就大大降低了。所以0.8后提供了Replication机制来保证Broker的failover。</p><p>引入Replication之后，同一个Partition可能会有多个Replica，而这时需要在这些Replication之间选出一个Leader，Producer和Consumer只与这个Leader交互，其它Replica作为Follower从Leader中复制数据。</p><p><img src="/2020/10/10/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/%E4%BA%8C.kafka%E5%85%A5%E9%97%A8%E7%90%86%E8%A7%A3/20170803142704015" alt="图片描述"></p><p><strong>2) 副本放置策略</strong></p><p>为了更好的做负载均衡，Kafka尽量将所有的Partition均匀分配到整个集群上。Kafka分配Replica的算法如下：</p><ul><li>将所有存活的N个Brokers和待分配的Partition排序</li><li>将第i个Partition分配到第(i mod n)个Broker上，这个Partition的第一个Replica存在于这个分配的Broker上，并且会作为partition的优先副本</li><li>将第i个Partition的第j个Replica分配到第((i + j) mod n)个Broker上</li></ul><p>假设集群一共有4个brokers，一个topic有4个partition，每个Partition有3个副本。下图是每个Broker上的副本分配情况。</p><p><img src="/2020/10/10/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/%E4%BA%8C.kafka%E5%85%A5%E9%97%A8%E7%90%86%E8%A7%A3/20170803142856639" alt="图片描述"></p><p><strong>3) 同步策略</strong></p><p>Producer在发布消息到某个Partition时，先通过ZooKeeper找到该Partition的Leader，然后无论该Topic的Replication Factor为多少，Producer只将该消息发送到该Partition的Leader。Leader会将该消息写入其本地Log。每个Follower都从Leader pull数据。这种方式上，Follower存储的数据顺序与Leader保持一致。Follower在收到该消息并写入其Log后，向Leader发送ACK。一旦Leader收到了ISR中的所有Replica的ACK，该消息就被认为已经commit了，Leader将增加HW并且向Producer发送ACK。</p><p>为了提高性能，每个Follower在接收到数据后就立马向Leader发送ACK，而非等到数据写入Log中。因此，对于已经commit的消息，Kafka只能保证它被存于多个Replica的内存中，而不能保证它们被持久化到磁盘中，也就不能完全保证异常发生后该条消息一定能被Consumer消费。</p><p>Consumer读消息也是从Leader读取，只有被commit过的消息才会暴露给Consumer。</p><p>Kafka Replication的数据流如下图所示：</p><p><img src="/2020/10/10/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/%E4%BA%8C.kafka%E5%85%A5%E9%97%A8%E7%90%86%E8%A7%A3/20170803143127773" alt="图片描述"></p><p>对于Kafka而言，定义一个Broker是否“活着”包含两个条件：</p><ul><li>一是它必须维护与ZooKeeper的session（这个通过ZooKeeper的Heartbeat机制来实现）。</li><li>二是Follower必须能够及时将Leader的消息复制过来，不能“落后太多”。</li></ul><p>Leader会跟踪与其保持同步的Replica列表，该列表称为ISR（即in-sync Replica）。如果一个Follower宕机，或者落后太多，Leader将把它从ISR中移除。这里所描述的“落后太多”指Follower复制的消息落后于Leader后的条数超过预定值或者Follower超过一定时间未向Leader发送fetch请求。</p><p>Kafka只解决fail/recover，一条消息只有被ISR里的所有Follower都从Leader复制过去才会被认为已提交。这样就避免了部分数据被写进了Leader，还没来得及被任何Follower复制就宕机了，而造成数据丢失（Consumer无法消费这些数据）。而对于Producer而言，它可以选择是否等待消息commit。这种机制确保了只要ISR有一个或以上的Follower，一条被commit的消息就不会丢失。</p><p><strong>4) leader选举</strong></p><p>Leader选举本质上是一个分布式锁，有两种方式实现基于ZooKeeper的分布式锁：</p><ul><li>节点名称唯一性：多个客户端创建一个节点，只有成功创建节点的客户端才能获得锁</li><li>临时顺序节点：所有客户端在某个目录下创建自己的临时顺序节点，只有序号最小的才获得锁</li></ul><p>Majority Vote的选举策略和ZooKeeper中的Zab选举是类似的，实际上ZooKeeper内部本身就实现了少数服从多数的选举策略。kafka中对于Partition的leader副本的选举采用了第一种方法：为Partition分配副本，指定一个ZNode临时节点，第一个成功创建节点的副本就是Leader节点，其他副本会在这个ZNode节点上注册Watcher监听器，一旦Leader宕机，对应的临时节点就会被自动删除，这时注册在该节点上的所有Follower都会收到监听器事件，它们都会尝试创建该节点，只有创建成功的那个follower才会成为Leader（ZooKeeper保证对于一个节点只有一个客户端能创建成功），其他follower继续重新注册监听事件。</p><p><strong>Kafka消息分组，消息消费原理</strong></p><p>同一Topic的一条消息只能被同一个Consumer Group内的一个Consumer消费，但多个Consumer Group可同时消费这一消息。</p><p><img src="/2020/10/10/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/%E4%BA%8C.kafka%E5%85%A5%E9%97%A8%E7%90%86%E8%A7%A3/20170803143338094" alt="图片描述"></p><p>这是Kafka用来实现一个Topic消息的广播（发给所有的Consumer）和单播（发给某一个Consumer）的手段。一个Topic可以对应多个Consumer Group。如果需要实现广播，只要每个Consumer有一个独立的Group就可以了。要实现单播只要所有的Consumer在同一个Group里。用Consumer Group还可以将Consumer进行自由的分组而不需要多次发送消息到不同的Topic。</p><p><strong>Push vs. Pull</strong></p><p>作为一个消息系统，Kafka遵循了传统的方式，选择由Producer向broker push消息并由Consumer从broker pull消息。</p><p>push模式很难适应消费速率不同的消费者，因为消息发送速率是由broker决定的。push模式的目标是尽可能以最快速度传递消息，但是这样很容易造成Consumer来不及处理消息，典型的表现就是拒绝服务以及网络拥塞。而pull模式则可以根据Consumer的消费能力以适当的速率消费消息。</p><p>对于Kafka而言，pull模式更合适。pull模式可简化broker的设计，Consumer可自主控制消费消息的速率，同时Consumer可以自己控制消费方式——即可批量消费也可逐条消费，同时还能选择不同的提交方式从而实现不同的传输语义。</p><h3 id="Kafak顺序写入与数据读取"><a href="#Kafak顺序写入与数据读取" class="headerlink" title="Kafak顺序写入与数据读取"></a>Kafak顺序写入与数据读取</h3><p>生产者（producer）是负责向Kafka提交数据的，Kafka会把收到的消息都写入到硬盘中，它绝对不会丢失数据。为了优化写入速度Kafak采用了两个技术，顺序写入和MMFile。</p><p><strong>顺序写入</strong></p><p>因为硬盘是机械结构，每次读写都会寻址，写入，其中寻址是一个“机械动作”，它是最耗时的。所以硬盘最“讨厌”随机I/O，最喜欢顺序I/O。为了提高读写硬盘的速度，Kafka就是使用顺序I/O。</p><p>每条消息都被append到该Partition中，属于顺序写磁盘，因此效率非常高。</p><p><img src="/2020/10/10/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/%E4%BA%8C.kafka%E5%85%A5%E9%97%A8%E7%90%86%E8%A7%A3/20170803143537953" alt="图片描述"></p><p>对于传统的message queue而言，一般会删除已经被消费的消息，而Kafka是不会删除数据的，它会把所有的数据都保留下来，每个消费者（Consumer）对每个Topic都有一个offset用来表示读取到了第几条数据。</p><p><img src="/2020/10/10/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/%E4%BA%8C.kafka%E5%85%A5%E9%97%A8%E7%90%86%E8%A7%A3/20170803143609250" alt="图片描述"></p><p>即便是顺序写入硬盘，硬盘的访问速度还是不可能追上内存。所以Kafka的数据并不是实时的写入硬盘，它充分利用了现代操作系统分页存储来利用内存提高I/O效率。</p><p>在Linux Kernal 2.2之后出现了一种叫做“零拷贝(zero-copy)”系统调用机制，就是跳过“用户缓冲区”的拷贝，建立一个磁盘空间和内存空间的直接映射，数据不再复制到“用户态缓冲区”系统上下文切换减少2次，可以提升一倍性能。</p><p><img src="/2020/10/10/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/%E4%BA%8C.kafka%E5%85%A5%E9%97%A8%E7%90%86%E8%A7%A3/20170803143852495" alt="图片描述"></p><p>通过mmap，进程像读写硬盘一样读写内存（当然是虚拟机内存）。使用这种方式可以获取很大的I/O提升，省去了用户空间到内核空间复制的开销（调用文件的read会把数据先放到内核空间的内存中，然后再复制到用户空间的内存中。）</p><p><strong>消费者（读取数据）</strong></p><p>试想一下，一个Web Server传送一个静态文件，如何优化？答案是zero copy。传统模式下我们从硬盘读取一个文件是这样的。</p><p><img src="/2020/10/10/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/%E4%BA%8C.kafka%E5%85%A5%E9%97%A8%E7%90%86%E8%A7%A3/20170803143918190" alt="图片描述"></p><p>先复制到内核空间（read是系统调用，放到了DMA，所以用内核空间），然后复制到用户空间（1、2）；从用户空间重新复制到内核空间（你用的socket是系统调用，所以它也有自己的内核空间），最后发送给网卡（3、4）。</p><p><img src="/2020/10/10/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/%E4%BA%8C.kafka%E5%85%A5%E9%97%A8%E7%90%86%E8%A7%A3/20170803143938300" alt="图片描述"></p><p>Zero Copy中直接从内核空间（DMA的）到内核空间（Socket的），然后发送网卡。这个技术非常普遍，Nginx也是用的这种技术。</p><p>实际上，Kafka把所有的消息都存放在一个一个的文件中，当消费者需要数据的时候Kafka直接把“文件”发送给消费者。当不需要把整个文件发出去的时候，Kafka通过调用Zero Copy的sendfile这个函数，这个函数包括：</p><ul><li>out_fd作为输出（一般及时socket的句柄）</li><li>in_fd作为输入文件句柄</li><li>off_t表示in_fd的偏移（从哪里开始读取）</li><li>size_t表示读取多少个 </li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息中间件 </tag>
            
            <tag> kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一.kafka入门安装使用</title>
      <link href="2020/10/10/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/%E4%B8%80.kafka%E5%85%A5%E9%97%A8%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/"/>
      <url>2020/10/10/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/kafka/%E4%B8%80.kafka%E5%85%A5%E9%97%A8%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>安装环境是centos7,由于kafka很多核心基于zookeeper特性实现,而zookeeper是java编写运行在JVM上,所以需要保证有java8以上的JDK环境</p><h2 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h2><p>  <a href="http://kafka.apache.org/downloads.html">http://kafka.apache.org/downloads.html</a></p><h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><pre class=" language-shell"><code class="language-shell">#1.解压kafka[root@localhost ~]# tar -xzvf kafka_2.12-2.6.0.tgz[root@localhost ~]# lsanaconda-ks.cfg  kafka_2.12-2.6.0  kafka_2.12-2.6.0.tgz#2.进入文件目录 启动zookeeper[root@localhost ~]# cd kafka_2.12-2.6.0[root@localhost kafka_2.12-2.6.0]# bin/zookeeper-server-start.sh config/zookeeper.properties#3.修改server.properties的advertised.listeners以供java API调用advertised.listeners=PLAINTEXT://192.168.20.151:9092#4.新开终端,启动kafka[root@localhost ~]# cd kafka_2.12-2.6.0[root@localhost kafka_2.12-2.6.0]# bin/kafka-server-start.sh config/server.properties#启动生产者    bin/kafka-console-producer.sh --broker-list localhost:9092 --topic CCTV#启动消费者    bin/kafka-console-consumer.sh --zookeeper localhost:2181 --topic CCTV</code></pre><h2 id="配置讲解"><a href="#配置讲解" class="headerlink" title="配置讲解"></a>配置讲解</h2><table><thead><tr><th>参数</th><th>说明(解释)</th></tr></thead><tbody><tr><td>broker.id =0</td><td>每一个broker在集群中的唯一表示，要求是正数。当该服务器的IP地址发生改变时，broker.id没有变化，则不会影响consumers的消息情况</td></tr><tr><td>log.dirs=/data/kafka-logs</td><td>kafka数据的存放地址，多个地址的话用逗号分割/data/kafka-logs-1，/data/kafka-logs-2</td></tr><tr><td>port =9092</td><td>broker server服务端口</td></tr><tr><td>message.max.bytes =6525000</td><td>表示消息体的最大大小，单位是字节</td></tr><tr><td>num.network.threads =4</td><td>broker处理消息的最大线程数，一般情况下不需要去修改</td></tr><tr><td>num.io.threads =8</td><td>broker处理磁盘IO的线程数，数值应该大于你的硬盘数</td></tr><tr><td>background.threads =4</td><td>一些后台任务处理的线程数，例如过期消息文件的删除等，一般情况下不需要去做修改</td></tr><tr><td>queued.max.requests =500</td><td>等待IO线程处理的请求队列最大数，若是等待IO的请求超过这个数值，那么会停止接受外部消息，应该是一种自我保护机制。</td></tr><tr><td>host.name</td><td>broker的主机地址，若是设置了，那么会绑定到这个地址上，若是没有，会绑定到所有的接口上，并将其中之一发送到ZK，一般不设置</td></tr><tr><td>socket.send.buffer.bytes=100*1024</td><td>socket的发送缓冲区，socket的调优参数SO_SNDBUFF</td></tr><tr><td>socket.receive.buffer.bytes =100*1024</td><td>socket的接受缓冲区，socket的调优参数SO_RCVBUFF</td></tr><tr><td>socket.request.max.bytes =100<em>1024</em>1024</td><td>socket请求的最大数值，防止serverOOM，message.max.bytes必然要小于socket.request.max.bytes，会被topic创建时的指定参数覆盖</td></tr><tr><td>log.segment.bytes =1024<em>1024</em>1024</td><td>topic的分区是以一堆segment文件存储的，这个控制每个segment的大小，会被topic创建时的指定参数覆盖</td></tr><tr><td>log.roll.hours =24*7</td><td>这个参数会在日志segment没有达到log.segment.bytes设置的大小，也会强制新建一个segment会被 topic创建时的指定参数覆盖</td></tr><tr><td>log.cleanup.policy = delete</td><td>日志清理策略选择有：delete和compact主要针对过期数据的处理，或是日志文件达到限制的额度，会被 topic创建时的指定参数覆盖</td></tr><tr><td>log.retention.minutes=3days</td><td>数据存储的最大时间超过这个时间会根据log.cleanup.policy设置的策略处理数据，也就是消费端能够多久去消费数据log.retention.bytes和log.retention.minutes任意一个达到要求，都会执行删除，会被topic创建时的指定参数覆盖</td></tr><tr><td>log.retention.bytes=-1</td><td>topic每个分区的最大文件大小，一个topic的大小限制 =分区数*log.retention.bytes。-1没有大小限log.retention.bytes和log.retention.minutes任意一个达到要求，都会执行删除，会被topic创建时的指定参数覆盖</td></tr><tr><td>log.retention.check.interval.ms=5minutes</td><td>文件大小检查的周期时间，是否处罚 log.cleanup.policy中设置的策略</td></tr><tr><td>log.cleaner.enable=<strong>false</strong></td><td>是否开启日志压缩</td></tr><tr><td>log.cleaner.threads = 2</td><td>日志压缩运行的线程数</td></tr><tr><td>log.cleaner.io.max.bytes.per.second=None</td><td>日志压缩时候处理的最大大小</td></tr><tr><td>log.cleaner.dedupe.buffer.size=500<em>1024</em>1024</td><td>日志压缩去重时候的缓存空间，在空间允许的情况下，越大越好</td></tr><tr><td>log.cleaner.io.buffer.size=512*1024</td><td>日志清理时候用到的IO块大小一般不需要修改</td></tr><tr><td>log.cleaner.io.buffer.load.factor =0.9</td><td>日志清理中hash表的扩大因子一般不需要修改</td></tr><tr><td>log.cleaner.backoff.ms =15000</td><td>检查是否处罚日志清理的间隔</td></tr><tr><td>log.cleaner.min.cleanable.ratio=0.5</td><td>日志清理的频率控制，越大意味着更高效的清理，同时会存在一些空间上的浪费，会被topic创建时的指定参数覆盖</td></tr><tr><td>log.cleaner.delete.retention.ms =1day</td><td>对于压缩的日志保留的最长时间，也是客户端消费消息的最长时间，同log.retention.minutes的区别在于一个控制未压缩数据，一个控制压缩后的数据。会被topic创建时的指定参数覆盖</td></tr><tr><td>log.index.size.max.bytes =10<em>1024</em>1024</td><td>对于segment日志的索引文件大小限制，会被topic创建时的指定参数覆盖</td></tr><tr><td>log.index.interval.bytes =4096</td><td>当执行一个fetch操作后，需要一定的空间来扫描最近的offset大小，设置越大，代表扫描速度越快，但是也更好内存，一般情况下不需要搭理这个参数</td></tr><tr><td>log.flush.interval.messages=None</td><td>log文件”sync”到磁盘之前累积的消息条数,因为磁盘IO操作是一个慢操作,但又是一个”数据可靠性”的必要手段,所以此参数的设置,需要在**”<strong><strong>数据可靠性</strong></strong>“<strong>与”性能”之间做必要的权衡.如果此值过大,将会导致每次”fsync”的时间较长(IO阻塞),如果此值过小,将会导致</strong>“fsync”**的次数较多,这也意味着整体的client请求有一定的延迟.物理server故障,将会导致没有fsync的消息丢失.</td></tr><tr><td>log.flush.scheduler.interval.ms =3000</td><td>检查是否需要固化到硬盘的时间间隔</td></tr><tr><td>log.flush.interval.ms = None</td><td>仅仅通过interval来控制消息的磁盘写入时机,是不足的.此参数用于控制**”fsync”**的时间间隔,如果消息量始终没有达到阀值,但是离上一次磁盘同步的时间间隔达到阀值,也将触发.</td></tr><tr><td>log.delete.delay.ms =60000</td><td>文件在索引中清除后保留的时间一般不需要去修改</td></tr><tr><td>log.flush.offset.checkpoint.interval.ms =60000</td><td>控制上次固化硬盘的时间点，以便于数据恢复一般不需要去修改</td></tr><tr><td>auto.create.topics.enable =<strong>true</strong></td><td>是否允许自动创建topic，若是<strong>false</strong>，就需要通过命令创建topic</td></tr><tr><td><strong>default</strong>.replication.factor =1</td><td>是否允许自动创建topic，若是<strong>false</strong>，就需要通过命令创建topic</td></tr><tr><td>num.partitions =1</td><td>每个topic的分区个数，若是在topic创建时候没有指定的话会被topic创建时的指定参数覆盖</td></tr><tr><td></td><td></td></tr><tr><td>以下是kafka中Leader,replicas配置参数</td><td></td></tr><tr><td>controller.socket.timeout.ms =30000</td><td>partition leader与replicas之间通讯时,socket的超时时间</td></tr><tr><td>controller.message.queue.size=10</td><td>partition leader与replicas数据同步时,消息的队列尺寸</td></tr><tr><td>replica.lag.time.max.ms =10000</td><td>replicas响应partition leader的最长等待时间，若是超过这个时间，就将replicas列入ISR(in-sync replicas)，并认为它是死的，不会再加入管理中</td></tr><tr><td>replica.lag.max.messages =4000</td><td>如果follower落后与leader太多,将会认为此follower[或者说partition relicas]已经失效##通常,在follower与leader通讯时,因为网络延迟或者链接断开,总会导致replicas中消息同步滞后##如果消息之后太多,leader将认为此follower网络延迟较大或者消息吞吐能力有限,将会把此replicas迁移##到其他follower中.##在broker数量较少,或者网络不足的环境中,建议提高此值.</td></tr><tr><td>replica.socket.timeout.ms=30*1000</td><td>follower与leader之间的socket超时时间</td></tr><tr><td>replica.socket.receive.buffer.bytes=64*1024</td><td>leader复制时候的socket缓存大小</td></tr><tr><td>replica.fetch.max.bytes =1024*1024</td><td>replicas每次获取数据的最大大小</td></tr><tr><td>replica.fetch.wait.max.ms =500</td><td>replicas同leader之间通信的最大等待时间，失败了会重试</td></tr><tr><td>replica.fetch.min.bytes =1</td><td>fetch的最小数据尺寸,如果leader中尚未同步的数据不足此值,将会阻塞,直到满足条件</td></tr><tr><td>num.replica.fetchers=1</td><td>leader进行复制的线程数，增大这个数值会增加follower的IO</td></tr><tr><td>replica.high.watermark.checkpoint.interval.ms =5000</td><td>每个replica检查是否将最高水位进行固化的频率</td></tr><tr><td>controlled.shutdown.enable =<strong>false</strong></td><td>是否允许控制器关闭broker ,若是设置为<strong>true</strong>,会关闭所有在这个broker上的leader，并转移到其他broker</td></tr><tr><td>controlled.shutdown.max.retries =3</td><td>控制器关闭的尝试次数</td></tr><tr><td>controlled.shutdown.retry.backoff.ms =5000</td><td>每次关闭尝试的时间间隔</td></tr><tr><td>leader.imbalance.per.broker.percentage =10</td><td>leader的不平衡比例，若是超过这个数值，会对分区进行重新的平衡</td></tr><tr><td>leader.imbalance.check.interval.seconds =300</td><td>检查leader是否不平衡的时间间隔</td></tr><tr><td>offset.metadata.max.bytes</td><td>客户端保留offset信息的最大空间大小</td></tr><tr><td>kafka中zookeeper参数配置</td><td></td></tr><tr><td>zookeeper.connect = localhost:2181</td><td>zookeeper集群的地址，可以是多个，多个之间用逗号分割hostname1:port1,hostname2:port2,hostname3:port3</td></tr><tr><td>zookeeper.session.timeout.ms=6000</td><td>ZooKeeper的最大超时时间，就是心跳的间隔，若是没有反映，那么认为已经死了，不易过大</td></tr><tr><td>zookeeper.connection.timeout.ms =6000</td><td>ZooKeeper的连接超时时间</td></tr><tr><td>zookeeper.sync.time.ms =2000</td><td>ZooKeeper集群中leader和follower之间的同步实际那</td></tr></tbody></table><h2 id="JAVA-API测试"><a href="#JAVA-API测试" class="headerlink" title="JAVA API测试"></a>JAVA API测试</h2><pre class=" language-xml"><code class="language-xml">        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.kafka<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>kafka-clients<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>1.0.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> kafka<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>kafka<span class="token punctuation">.</span>clients<span class="token punctuation">.</span>consumer<span class="token punctuation">.</span>ConsumerRecord<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>kafka<span class="token punctuation">.</span>clients<span class="token punctuation">.</span>consumer<span class="token punctuation">.</span>ConsumerRecords<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>kafka<span class="token punctuation">.</span>clients<span class="token punctuation">.</span>consumer<span class="token punctuation">.</span>KafkaConsumer<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>kafka<span class="token punctuation">.</span>clients<span class="token punctuation">.</span>producer<span class="token punctuation">.</span>KafkaProducer<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>kafka<span class="token punctuation">.</span>clients<span class="token punctuation">.</span>producer<span class="token punctuation">.</span>Producer<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>kafka<span class="token punctuation">.</span>clients<span class="token punctuation">.</span>producer<span class="token punctuation">.</span>ProducerRecord<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Date<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Properties<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * User: 李诗诚 * Date: 2020/10/10 * Time: 11:57 * Description: */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">KafkaTest</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String KAFKA_SERVERS <span class="token operator">=</span> <span class="token string">"192.168.20.151:9092"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                KafkaTest<span class="token punctuation">.</span><span class="token function">producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"生产者"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                KafkaTest<span class="token punctuation">.</span><span class="token function">consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"消费者"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 生产者,生产数据到kafka中     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Properties props <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//broker地址</span>        props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"bootstrap.servers"</span><span class="token punctuation">,</span> KAFKA_SERVERS<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//请求时候需要验证</span>        props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"acks"</span><span class="token punctuation">,</span> <span class="token string">"all"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//请求失败时候需要重试</span>        props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"retries"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//内存缓存区大小</span>        props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"buffer.memory"</span><span class="token punctuation">,</span> <span class="token number">33554432</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//指定消息key序列化方式</span>        props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"key.serializer"</span><span class="token punctuation">,</span>                <span class="token string">"org.apache.kafka.common.serialization.StringSerializer"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//指定消息本身的序列化方式</span>        props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"value.serializer"</span><span class="token punctuation">,</span>                <span class="token string">"org.apache.kafka.common.serialization.StringSerializer"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Producer<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> producer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">KafkaProducer</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            count<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                producer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ProducerRecord</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token string">"CCTV"</span><span class="token punctuation">,</span> Integer<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"ddddddd "</span> <span class="token operator">+</span> count <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 消费者,从指定kafka中获取数据进行消费     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        Properties props <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"bootstrap.servers"</span><span class="token punctuation">,</span> KAFKA_SERVERS<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//每个消费者分配独立的组号</span>        props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"group.id"</span><span class="token punctuation">,</span> <span class="token string">"test4"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//不同的组，可消费同一个topic的数据</span>        <span class="token comment" spellcheck="true">//若分区数大于1，则可以多线程，或集群消费数据</span>        <span class="token comment" spellcheck="true">//如果value合法，则自动提交偏移量</span>        props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"enable.auto.commit"</span><span class="token punctuation">,</span> <span class="token string">"true"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//设置多久一次更新被消费消息的偏移量</span>        props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"auto.commit.interval.ms"</span><span class="token punctuation">,</span> <span class="token string">"1000"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//设置会话响应的时间，超过这个时间kafka可以选择放弃消费或者消费下一条消息</span>        props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"session.timeout.ms"</span><span class="token punctuation">,</span> <span class="token string">"30000"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"key.deserializer"</span><span class="token punctuation">,</span>                <span class="token string">"org.apache.kafka.common.serialization.StringDeserializer"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"value.deserializer"</span><span class="token punctuation">,</span>                <span class="token string">"org.apache.kafka.common.serialization.StringDeserializer"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        KafkaConsumer<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> consumer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">KafkaConsumer</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>        consumer<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"CCTV"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            ConsumerRecords<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> records <span class="token operator">=</span> consumer<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>ConsumerRecord<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> record <span class="token operator">:</span> records<span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">// print the offset,key and value for the consumer records.</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"offset = %d, key = %s, value = %s\n"</span><span class="token punctuation">,</span>                        record<span class="token punctuation">.</span><span class="token function">offset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> record<span class="token punctuation">.</span><span class="token function">key</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> record<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> kafka </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息中间件 </tag>
            
            <tag> kafka </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git常用操作</title>
      <link href="2020/10/09/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/git/git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
      <url>2020/10/09/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7/git/git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="拉取指定分支项目"><a href="#拉取指定分支项目" class="headerlink" title="拉取指定分支项目"></a>拉取指定分支项目</h2><p><strong><code>git clone -b 想要拉取的分支名 xxx(URL) 文件名</code></strong></p><blockquote><p>如果未指定 <strong>文件名</strong>，则默认为 GitLab 上的项目名。</p></blockquote><hr><h2 id="分步版本："><a href="#分步版本：" class="headerlink" title="分步版本："></a>分步版本：</h2><h3 id="拉取项目"><a href="#拉取项目" class="headerlink" title="拉取项目"></a>拉取项目</h3><p>首先，进入到想要拉取分支的 <strong>项目</strong> 中 （首页为 <code>master</code> 分支）</p><p>点击上图中标注出来的 <strong>复制</strong> （复制 URL 到剪贴板）按钮复制路径</p><p>打开本地终端，进入到想把项目存放的 <strong>目录</strong>，<code>git clone xxx</code> ( xxx 为刚刚复制的 URL)</p><h3 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h3><p>使用 <code>git clone xxx</code> 命令后，系统会自动创建项目文件夹</p><p>进入 <strong>项目文件夹目录</strong>，此时所处分支为 <code>master</code>分支</p><p><code>git checkout -b 分支名</code> 新建分支（分支名为 想要拉取的 <strong>指定分支的</strong> 分支名），然后此时系统会自动切换为新建的这个分支</p><p><code>git pull</code> 拉取分支，更新分支内容</p><p>此时会提示让关联分支，按照提示内容输入命令 <code>git branch --set-upstream-to=origin/新建的那个分支名</code></p><p>重新 <code>git pull</code></p><p>此时指定分支上的内容就获取完毕。</p><blockquote><p><strong>git 命令</strong>：</p><ul><li><p><code>git checkout -b 分支名</code>：新建并切换到新分支。</p></li><li><p><code>git branch</code>: 查看当前分支。</p></li><li><p><code>git checkout 分支名</code>：切换分支（已有分支）。</p></li><li><p><code>git branch -d 分支名</code>：删除分支。</p></li><li><p><code>git pull</code>：拉取分支最新内容。</p></li><li><p><code>git merge develop</code>：将本分支内容合并到 develop 分支上。</p></li><li><p><code>git reset --hard origin/当前分支名</code>：将当前分支本地编辑的所有内容舍弃。</p></li></ul><p>  提交的时候：</p><ul><li><p><code>git add .</code></p></li><li><p><code>git commit -m "描述提交的内容"</code></p></li><li><p><code>git push</code></p></li></ul></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 版本控制工具 </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Centos7常用操作</title>
      <link href="2020/10/09/centos/Centos7%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
      <url>2020/10/09/centos/Centos7%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>命令</th><th></th><th></th></tr></thead><tbody><tr><td>ip add</td><td></td><td>查看系统当前IP地址</td></tr><tr><td>nmtui</td><td></td><td>调出系统配置修改窗口</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Centos </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Centos7 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Thread的基本使用</title>
      <link href="2020/09/17/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Thread%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>2020/09/17/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Thread%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="一-线程启动"><a href="#一-线程启动" class="headerlink" title="一.线程启动"></a>一.线程启动</h1><p>Thread是java中操作线程的类,常用调用线程的方式有2中</p><ol><li>继承Thread类,重写run方法,</li><li>继承Runable接口,实现run方法</li></ol><p>不管哪种方式,最终启动线程都是由Thread的start方法来启动线程</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * User: 李诗诚 * Date: 2020/9/16 * Time: 9:30 * Description: 线程启动的2中方式 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadStart</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ThreadA threadA <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ThreadB threadB <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 实现runable接口的类需要当做runable抽象传入到Thread中启动</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>threadA<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 继承Thread类可以直接调用start方法启动</span>        threadB<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ThreadA</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/**         * When an object implementing interface &lt;code>Runnable&lt;/code> is used         * to create a thread, starting the thread causes the object's         * &lt;code>run&lt;/code> method to be called in that separately executing         * thread.         * &lt;p>         * The general contract of the method &lt;code>run&lt;/code> is that it may         * take any action whatsoever.         *         * @see java.lang.Thread#run()         */</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"我实现了Runnable接口"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ThreadB</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"我继承了Thread类,重写了run方法"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Thread </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
